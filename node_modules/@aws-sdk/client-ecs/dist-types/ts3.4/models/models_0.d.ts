import { ExceptionOptionType as __ExceptionOptionType } from "@smithy/smithy-client";
import { ECSServiceException as __BaseException } from "./ECSServiceException";
export declare class AccessDeniedException extends __BaseException {
  readonly name: "AccessDeniedException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<AccessDeniedException, __BaseException>
  );
}
export declare const AgentUpdateStatus: {
  readonly FAILED: "FAILED";
  readonly PENDING: "PENDING";
  readonly STAGED: "STAGED";
  readonly STAGING: "STAGING";
  readonly UPDATED: "UPDATED";
  readonly UPDATING: "UPDATING";
};
export type AgentUpdateStatus =
  (typeof AgentUpdateStatus)[keyof typeof AgentUpdateStatus];
export declare class ClientException extends __BaseException {
  readonly name: "ClientException";
  readonly $fault: "client";
  constructor(opts: __ExceptionOptionType<ClientException, __BaseException>);
}
export declare const ManagedDraining: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
};
export type ManagedDraining =
  (typeof ManagedDraining)[keyof typeof ManagedDraining];
export declare const ManagedScalingStatus: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
};
export type ManagedScalingStatus =
  (typeof ManagedScalingStatus)[keyof typeof ManagedScalingStatus];
export interface ManagedScaling {
  status?: ManagedScalingStatus;
  targetCapacity?: number;
  minimumScalingStepSize?: number;
  maximumScalingStepSize?: number;
  instanceWarmupPeriod?: number;
}
export declare const ManagedTerminationProtection: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
};
export type ManagedTerminationProtection =
  (typeof ManagedTerminationProtection)[keyof typeof ManagedTerminationProtection];
export interface AutoScalingGroupProvider {
  autoScalingGroupArn: string | undefined;
  managedScaling?: ManagedScaling;
  managedTerminationProtection?: ManagedTerminationProtection;
  managedDraining?: ManagedDraining;
}
export interface Tag {
  key?: string;
  value?: string;
}
export interface CreateCapacityProviderRequest {
  name: string | undefined;
  autoScalingGroupProvider: AutoScalingGroupProvider | undefined;
  tags?: Tag[];
}
export declare const CapacityProviderStatus: {
  readonly ACTIVE: "ACTIVE";
  readonly INACTIVE: "INACTIVE";
};
export type CapacityProviderStatus =
  (typeof CapacityProviderStatus)[keyof typeof CapacityProviderStatus];
export declare const CapacityProviderUpdateStatus: {
  readonly DELETE_COMPLETE: "DELETE_COMPLETE";
  readonly DELETE_FAILED: "DELETE_FAILED";
  readonly DELETE_IN_PROGRESS: "DELETE_IN_PROGRESS";
  readonly UPDATE_COMPLETE: "UPDATE_COMPLETE";
  readonly UPDATE_FAILED: "UPDATE_FAILED";
  readonly UPDATE_IN_PROGRESS: "UPDATE_IN_PROGRESS";
};
export type CapacityProviderUpdateStatus =
  (typeof CapacityProviderUpdateStatus)[keyof typeof CapacityProviderUpdateStatus];
export interface CapacityProvider {
  capacityProviderArn?: string;
  name?: string;
  status?: CapacityProviderStatus;
  autoScalingGroupProvider?: AutoScalingGroupProvider;
  updateStatus?: CapacityProviderUpdateStatus;
  updateStatusReason?: string;
  tags?: Tag[];
}
export interface CreateCapacityProviderResponse {
  capacityProvider?: CapacityProvider;
}
export declare class InvalidParameterException extends __BaseException {
  readonly name: "InvalidParameterException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<InvalidParameterException, __BaseException>
  );
}
export declare class LimitExceededException extends __BaseException {
  readonly name: "LimitExceededException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<LimitExceededException, __BaseException>
  );
}
export declare class ServerException extends __BaseException {
  readonly name: "ServerException";
  readonly $fault: "server";
  constructor(opts: __ExceptionOptionType<ServerException, __BaseException>);
}
export declare class UpdateInProgressException extends __BaseException {
  readonly name: "UpdateInProgressException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<UpdateInProgressException, __BaseException>
  );
}
export interface ExecuteCommandLogConfiguration {
  cloudWatchLogGroupName?: string;
  cloudWatchEncryptionEnabled?: boolean;
  s3BucketName?: string;
  s3EncryptionEnabled?: boolean;
  s3KeyPrefix?: string;
}
export declare const ExecuteCommandLogging: {
  readonly DEFAULT: "DEFAULT";
  readonly NONE: "NONE";
  readonly OVERRIDE: "OVERRIDE";
};
export type ExecuteCommandLogging =
  (typeof ExecuteCommandLogging)[keyof typeof ExecuteCommandLogging];
export interface ExecuteCommandConfiguration {
  kmsKeyId?: string;
  logging?: ExecuteCommandLogging;
  logConfiguration?: ExecuteCommandLogConfiguration;
}
export interface ManagedStorageConfiguration {
  kmsKeyId?: string;
  fargateEphemeralStorageKmsKeyId?: string;
}
export interface ClusterConfiguration {
  executeCommandConfiguration?: ExecuteCommandConfiguration;
  managedStorageConfiguration?: ManagedStorageConfiguration;
}
export interface CapacityProviderStrategyItem {
  capacityProvider: string | undefined;
  weight?: number;
  base?: number;
}
export interface ClusterServiceConnectDefaultsRequest {
  namespace: string | undefined;
}
export declare const ClusterSettingName: {
  readonly CONTAINER_INSIGHTS: "containerInsights";
};
export type ClusterSettingName =
  (typeof ClusterSettingName)[keyof typeof ClusterSettingName];
export interface ClusterSetting {
  name?: ClusterSettingName;
  value?: string;
}
export interface CreateClusterRequest {
  clusterName?: string;
  tags?: Tag[];
  settings?: ClusterSetting[];
  configuration?: ClusterConfiguration;
  capacityProviders?: string[];
  defaultCapacityProviderStrategy?: CapacityProviderStrategyItem[];
  serviceConnectDefaults?: ClusterServiceConnectDefaultsRequest;
}
export interface KeyValuePair {
  name?: string;
  value?: string;
}
export interface Attachment {
  id?: string;
  type?: string;
  status?: string;
  details?: KeyValuePair[];
}
export interface ClusterServiceConnectDefaults {
  namespace?: string;
}
export interface Cluster {
  clusterArn?: string;
  clusterName?: string;
  configuration?: ClusterConfiguration;
  status?: string;
  registeredContainerInstancesCount?: number;
  runningTasksCount?: number;
  pendingTasksCount?: number;
  activeServicesCount?: number;
  statistics?: KeyValuePair[];
  tags?: Tag[];
  settings?: ClusterSetting[];
  capacityProviders?: string[];
  defaultCapacityProviderStrategy?: CapacityProviderStrategyItem[];
  attachments?: Attachment[];
  attachmentsStatus?: string;
  serviceConnectDefaults?: ClusterServiceConnectDefaults;
}
export interface CreateClusterResponse {
  cluster?: Cluster;
}
export declare class NamespaceNotFoundException extends __BaseException {
  readonly name: "NamespaceNotFoundException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<NamespaceNotFoundException, __BaseException>
  );
}
export declare class ClusterNotFoundException extends __BaseException {
  readonly name: "ClusterNotFoundException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<ClusterNotFoundException, __BaseException>
  );
}
export interface DeploymentAlarms {
  alarmNames: string[] | undefined;
  enable: boolean | undefined;
  rollback: boolean | undefined;
}
export interface DeploymentCircuitBreaker {
  enable: boolean | undefined;
  rollback: boolean | undefined;
}
export interface DeploymentConfiguration {
  deploymentCircuitBreaker?: DeploymentCircuitBreaker;
  maximumPercent?: number;
  minimumHealthyPercent?: number;
  alarms?: DeploymentAlarms;
}
export declare const DeploymentControllerType: {
  readonly CODE_DEPLOY: "CODE_DEPLOY";
  readonly ECS: "ECS";
  readonly EXTERNAL: "EXTERNAL";
};
export type DeploymentControllerType =
  (typeof DeploymentControllerType)[keyof typeof DeploymentControllerType];
export interface DeploymentController {
  type: DeploymentControllerType | undefined;
}
export declare const LaunchType: {
  readonly EC2: "EC2";
  readonly EXTERNAL: "EXTERNAL";
  readonly FARGATE: "FARGATE";
};
export type LaunchType = (typeof LaunchType)[keyof typeof LaunchType];
export interface LoadBalancer {
  targetGroupArn?: string;
  loadBalancerName?: string;
  containerName?: string;
  containerPort?: number;
}
export declare const AssignPublicIp: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
};
export type AssignPublicIp =
  (typeof AssignPublicIp)[keyof typeof AssignPublicIp];
export interface AwsVpcConfiguration {
  subnets: string[] | undefined;
  securityGroups?: string[];
  assignPublicIp?: AssignPublicIp;
}
export interface NetworkConfiguration {
  awsvpcConfiguration?: AwsVpcConfiguration;
}
export declare const PlacementConstraintType: {
  readonly DISTINCT_INSTANCE: "distinctInstance";
  readonly MEMBER_OF: "memberOf";
};
export type PlacementConstraintType =
  (typeof PlacementConstraintType)[keyof typeof PlacementConstraintType];
export interface PlacementConstraint {
  type?: PlacementConstraintType;
  expression?: string;
}
export declare const PlacementStrategyType: {
  readonly BINPACK: "binpack";
  readonly RANDOM: "random";
  readonly SPREAD: "spread";
};
export type PlacementStrategyType =
  (typeof PlacementStrategyType)[keyof typeof PlacementStrategyType];
export interface PlacementStrategy {
  type?: PlacementStrategyType;
  field?: string;
}
export declare const PropagateTags: {
  readonly NONE: "NONE";
  readonly SERVICE: "SERVICE";
  readonly TASK_DEFINITION: "TASK_DEFINITION";
};
export type PropagateTags = (typeof PropagateTags)[keyof typeof PropagateTags];
export declare const SchedulingStrategy: {
  readonly DAEMON: "DAEMON";
  readonly REPLICA: "REPLICA";
};
export type SchedulingStrategy =
  (typeof SchedulingStrategy)[keyof typeof SchedulingStrategy];
export declare const LogDriver: {
  readonly AWSFIRELENS: "awsfirelens";
  readonly AWSLOGS: "awslogs";
  readonly FLUENTD: "fluentd";
  readonly GELF: "gelf";
  readonly JOURNALD: "journald";
  readonly JSON_FILE: "json-file";
  readonly SPLUNK: "splunk";
  readonly SYSLOG: "syslog";
};
export type LogDriver = (typeof LogDriver)[keyof typeof LogDriver];
export interface Secret {
  name: string | undefined;
  valueFrom: string | undefined;
}
export interface LogConfiguration {
  logDriver: LogDriver | undefined;
  options?: Record<string, string>;
  secretOptions?: Secret[];
}
export interface ServiceConnectClientAlias {
  port: number | undefined;
  dnsName?: string;
}
export interface TimeoutConfiguration {
  idleTimeoutSeconds?: number;
  perRequestTimeoutSeconds?: number;
}
export interface ServiceConnectTlsCertificateAuthority {
  awsPcaAuthorityArn?: string;
}
export interface ServiceConnectTlsConfiguration {
  issuerCertificateAuthority: ServiceConnectTlsCertificateAuthority | undefined;
  kmsKey?: string;
  roleArn?: string;
}
export interface ServiceConnectService {
  portName: string | undefined;
  discoveryName?: string;
  clientAliases?: ServiceConnectClientAlias[];
  ingressPortOverride?: number;
  timeout?: TimeoutConfiguration;
  tls?: ServiceConnectTlsConfiguration;
}
export interface ServiceConnectConfiguration {
  enabled: boolean | undefined;
  namespace?: string;
  services?: ServiceConnectService[];
  logConfiguration?: LogConfiguration;
}
export interface ServiceRegistry {
  registryArn?: string;
  port?: number;
  containerName?: string;
  containerPort?: number;
}
export declare const TaskFilesystemType: {
  readonly EXT3: "ext3";
  readonly EXT4: "ext4";
  readonly XFS: "xfs";
};
export type TaskFilesystemType =
  (typeof TaskFilesystemType)[keyof typeof TaskFilesystemType];
export declare const EBSResourceType: {
  readonly VOLUME: "volume";
};
export type EBSResourceType =
  (typeof EBSResourceType)[keyof typeof EBSResourceType];
export interface EBSTagSpecification {
  resourceType: EBSResourceType | undefined;
  tags?: Tag[];
  propagateTags?: PropagateTags;
}
export interface ServiceManagedEBSVolumeConfiguration {
  encrypted?: boolean;
  kmsKeyId?: string;
  volumeType?: string;
  sizeInGiB?: number;
  snapshotId?: string;
  iops?: number;
  throughput?: number;
  tagSpecifications?: EBSTagSpecification[];
  roleArn: string | undefined;
  filesystemType?: TaskFilesystemType;
}
export interface ServiceVolumeConfiguration {
  name: string | undefined;
  managedEBSVolume?: ServiceManagedEBSVolumeConfiguration;
}
export interface CreateServiceRequest {
  cluster?: string;
  serviceName: string | undefined;
  taskDefinition?: string;
  loadBalancers?: LoadBalancer[];
  serviceRegistries?: ServiceRegistry[];
  desiredCount?: number;
  clientToken?: string;
  launchType?: LaunchType;
  capacityProviderStrategy?: CapacityProviderStrategyItem[];
  platformVersion?: string;
  role?: string;
  deploymentConfiguration?: DeploymentConfiguration;
  placementConstraints?: PlacementConstraint[];
  placementStrategy?: PlacementStrategy[];
  networkConfiguration?: NetworkConfiguration;
  healthCheckGracePeriodSeconds?: number;
  schedulingStrategy?: SchedulingStrategy;
  deploymentController?: DeploymentController;
  tags?: Tag[];
  enableECSManagedTags?: boolean;
  propagateTags?: PropagateTags;
  enableExecuteCommand?: boolean;
  serviceConnectConfiguration?: ServiceConnectConfiguration;
  volumeConfigurations?: ServiceVolumeConfiguration[];
}
export interface DeploymentEphemeralStorage {
  kmsKeyId?: string;
}
export declare const DeploymentRolloutState: {
  readonly COMPLETED: "COMPLETED";
  readonly FAILED: "FAILED";
  readonly IN_PROGRESS: "IN_PROGRESS";
};
export type DeploymentRolloutState =
  (typeof DeploymentRolloutState)[keyof typeof DeploymentRolloutState];
export interface ServiceConnectServiceResource {
  discoveryName?: string;
  discoveryArn?: string;
}
export interface Deployment {
  id?: string;
  status?: string;
  taskDefinition?: string;
  desiredCount?: number;
  pendingCount?: number;
  runningCount?: number;
  failedTasks?: number;
  createdAt?: Date;
  updatedAt?: Date;
  capacityProviderStrategy?: CapacityProviderStrategyItem[];
  launchType?: LaunchType;
  platformVersion?: string;
  platformFamily?: string;
  networkConfiguration?: NetworkConfiguration;
  rolloutState?: DeploymentRolloutState;
  rolloutStateReason?: string;
  serviceConnectConfiguration?: ServiceConnectConfiguration;
  serviceConnectResources?: ServiceConnectServiceResource[];
  volumeConfigurations?: ServiceVolumeConfiguration[];
  fargateEphemeralStorage?: DeploymentEphemeralStorage;
}
export interface ServiceEvent {
  id?: string;
  createdAt?: Date;
  message?: string;
}
export declare const ScaleUnit: {
  readonly PERCENT: "PERCENT";
};
export type ScaleUnit = (typeof ScaleUnit)[keyof typeof ScaleUnit];
export interface Scale {
  value?: number;
  unit?: ScaleUnit;
}
export declare const StabilityStatus: {
  readonly STABILIZING: "STABILIZING";
  readonly STEADY_STATE: "STEADY_STATE";
};
export type StabilityStatus =
  (typeof StabilityStatus)[keyof typeof StabilityStatus];
export interface TaskSet {
  id?: string;
  taskSetArn?: string;
  serviceArn?: string;
  clusterArn?: string;
  startedBy?: string;
  externalId?: string;
  status?: string;
  taskDefinition?: string;
  computedDesiredCount?: number;
  pendingCount?: number;
  runningCount?: number;
  createdAt?: Date;
  updatedAt?: Date;
  launchType?: LaunchType;
  capacityProviderStrategy?: CapacityProviderStrategyItem[];
  platformVersion?: string;
  platformFamily?: string;
  networkConfiguration?: NetworkConfiguration;
  loadBalancers?: LoadBalancer[];
  serviceRegistries?: ServiceRegistry[];
  scale?: Scale;
  stabilityStatus?: StabilityStatus;
  stabilityStatusAt?: Date;
  tags?: Tag[];
  fargateEphemeralStorage?: DeploymentEphemeralStorage;
}
export interface Service {
  serviceArn?: string;
  serviceName?: string;
  clusterArn?: string;
  loadBalancers?: LoadBalancer[];
  serviceRegistries?: ServiceRegistry[];
  status?: string;
  desiredCount?: number;
  runningCount?: number;
  pendingCount?: number;
  launchType?: LaunchType;
  capacityProviderStrategy?: CapacityProviderStrategyItem[];
  platformVersion?: string;
  platformFamily?: string;
  taskDefinition?: string;
  deploymentConfiguration?: DeploymentConfiguration;
  taskSets?: TaskSet[];
  deployments?: Deployment[];
  roleArn?: string;
  events?: ServiceEvent[];
  createdAt?: Date;
  placementConstraints?: PlacementConstraint[];
  placementStrategy?: PlacementStrategy[];
  networkConfiguration?: NetworkConfiguration;
  healthCheckGracePeriodSeconds?: number;
  schedulingStrategy?: SchedulingStrategy;
  deploymentController?: DeploymentController;
  tags?: Tag[];
  createdBy?: string;
  enableECSManagedTags?: boolean;
  propagateTags?: PropagateTags;
  enableExecuteCommand?: boolean;
}
export interface CreateServiceResponse {
  service?: Service;
}
export declare class PlatformTaskDefinitionIncompatibilityException extends __BaseException {
  readonly name: "PlatformTaskDefinitionIncompatibilityException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      PlatformTaskDefinitionIncompatibilityException,
      __BaseException
    >
  );
}
export declare class PlatformUnknownException extends __BaseException {
  readonly name: "PlatformUnknownException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<PlatformUnknownException, __BaseException>
  );
}
export declare class UnsupportedFeatureException extends __BaseException {
  readonly name: "UnsupportedFeatureException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<UnsupportedFeatureException, __BaseException>
  );
}
export interface CreateTaskSetRequest {
  service: string | undefined;
  cluster: string | undefined;
  externalId?: string;
  taskDefinition: string | undefined;
  networkConfiguration?: NetworkConfiguration;
  loadBalancers?: LoadBalancer[];
  serviceRegistries?: ServiceRegistry[];
  launchType?: LaunchType;
  capacityProviderStrategy?: CapacityProviderStrategyItem[];
  platformVersion?: string;
  scale?: Scale;
  clientToken?: string;
  tags?: Tag[];
}
export interface CreateTaskSetResponse {
  taskSet?: TaskSet;
}
export declare class ServiceNotActiveException extends __BaseException {
  readonly name: "ServiceNotActiveException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<ServiceNotActiveException, __BaseException>
  );
}
export declare class ServiceNotFoundException extends __BaseException {
  readonly name: "ServiceNotFoundException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<ServiceNotFoundException, __BaseException>
  );
}
export declare const SettingName: {
  readonly AWSVPC_TRUNKING: "awsvpcTrunking";
  readonly CONTAINER_INSIGHTS: "containerInsights";
  readonly CONTAINER_INSTANCE_LONG_ARN_FORMAT: "containerInstanceLongArnFormat";
  readonly FARGATE_FIPS_MODE: "fargateFIPSMode";
  readonly FARGATE_TASK_RETIREMENT_WAIT_PERIOD: "fargateTaskRetirementWaitPeriod";
  readonly GUARD_DUTY_ACTIVATE: "guardDutyActivate";
  readonly SERVICE_LONG_ARN_FORMAT: "serviceLongArnFormat";
  readonly TAG_RESOURCE_AUTHORIZATION: "tagResourceAuthorization";
  readonly TASK_LONG_ARN_FORMAT: "taskLongArnFormat";
};
export type SettingName = (typeof SettingName)[keyof typeof SettingName];
export interface DeleteAccountSettingRequest {
  name: SettingName | undefined;
  principalArn?: string;
}
export declare const SettingType: {
  readonly AWS_MANAGED: "aws_managed";
  readonly USER: "user";
};
export type SettingType = (typeof SettingType)[keyof typeof SettingType];
export interface Setting {
  name?: SettingName;
  value?: string;
  principalArn?: string;
  type?: SettingType;
}
export interface DeleteAccountSettingResponse {
  setting?: Setting;
}
export declare const TargetType: {
  readonly CONTAINER_INSTANCE: "container-instance";
};
export type TargetType = (typeof TargetType)[keyof typeof TargetType];
export interface Attribute {
  name: string | undefined;
  value?: string;
  targetType?: TargetType;
  targetId?: string;
}
export interface DeleteAttributesRequest {
  cluster?: string;
  attributes: Attribute[] | undefined;
}
export interface DeleteAttributesResponse {
  attributes?: Attribute[];
}
export declare class TargetNotFoundException extends __BaseException {
  readonly name: "TargetNotFoundException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<TargetNotFoundException, __BaseException>
  );
}
export interface DeleteCapacityProviderRequest {
  capacityProvider: string | undefined;
}
export interface DeleteCapacityProviderResponse {
  capacityProvider?: CapacityProvider;
}
export declare class ClusterContainsContainerInstancesException extends __BaseException {
  readonly name: "ClusterContainsContainerInstancesException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      ClusterContainsContainerInstancesException,
      __BaseException
    >
  );
}
export declare class ClusterContainsServicesException extends __BaseException {
  readonly name: "ClusterContainsServicesException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      ClusterContainsServicesException,
      __BaseException
    >
  );
}
export declare class ClusterContainsTasksException extends __BaseException {
  readonly name: "ClusterContainsTasksException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<ClusterContainsTasksException, __BaseException>
  );
}
export interface DeleteClusterRequest {
  cluster: string | undefined;
}
export interface DeleteClusterResponse {
  cluster?: Cluster;
}
export interface DeleteServiceRequest {
  cluster?: string;
  service: string | undefined;
  force?: boolean;
}
export interface DeleteServiceResponse {
  service?: Service;
}
export interface DeleteTaskDefinitionsRequest {
  taskDefinitions: string[] | undefined;
}
export interface Failure {
  arn?: string;
  reason?: string;
  detail?: string;
}
export declare const Compatibility: {
  readonly EC2: "EC2";
  readonly EXTERNAL: "EXTERNAL";
  readonly FARGATE: "FARGATE";
};
export type Compatibility = (typeof Compatibility)[keyof typeof Compatibility];
export declare const ContainerCondition: {
  readonly COMPLETE: "COMPLETE";
  readonly HEALTHY: "HEALTHY";
  readonly START: "START";
  readonly SUCCESS: "SUCCESS";
};
export type ContainerCondition =
  (typeof ContainerCondition)[keyof typeof ContainerCondition];
export interface ContainerDependency {
  containerName: string | undefined;
  condition: ContainerCondition | undefined;
}
export declare const EnvironmentFileType: {
  readonly S3: "s3";
};
export type EnvironmentFileType =
  (typeof EnvironmentFileType)[keyof typeof EnvironmentFileType];
export interface EnvironmentFile {
  value: string | undefined;
  type: EnvironmentFileType | undefined;
}
export interface HostEntry {
  hostname: string | undefined;
  ipAddress: string | undefined;
}
export declare const FirelensConfigurationType: {
  readonly FLUENTBIT: "fluentbit";
  readonly FLUENTD: "fluentd";
};
export type FirelensConfigurationType =
  (typeof FirelensConfigurationType)[keyof typeof FirelensConfigurationType];
export interface FirelensConfiguration {
  type: FirelensConfigurationType | undefined;
  options?: Record<string, string>;
}
export interface HealthCheck {
  command: string[] | undefined;
  interval?: number;
  timeout?: number;
  retries?: number;
  startPeriod?: number;
}
export interface KernelCapabilities {
  add?: string[];
  drop?: string[];
}
export declare const DeviceCgroupPermission: {
  readonly MKNOD: "mknod";
  readonly READ: "read";
  readonly WRITE: "write";
};
export type DeviceCgroupPermission =
  (typeof DeviceCgroupPermission)[keyof typeof DeviceCgroupPermission];
export interface Device {
  hostPath: string | undefined;
  containerPath?: string;
  permissions?: DeviceCgroupPermission[];
}
export interface Tmpfs {
  containerPath: string | undefined;
  size: number | undefined;
  mountOptions?: string[];
}
export interface LinuxParameters {
  capabilities?: KernelCapabilities;
  devices?: Device[];
  initProcessEnabled?: boolean;
  sharedMemorySize?: number;
  tmpfs?: Tmpfs[];
  maxSwap?: number;
  swappiness?: number;
}
export interface MountPoint {
  sourceVolume?: string;
  containerPath?: string;
  readOnly?: boolean;
}
export declare const ApplicationProtocol: {
  readonly GRPC: "grpc";
  readonly HTTP: "http";
  readonly HTTP2: "http2";
};
export type ApplicationProtocol =
  (typeof ApplicationProtocol)[keyof typeof ApplicationProtocol];
export declare const TransportProtocol: {
  readonly TCP: "tcp";
  readonly UDP: "udp";
};
export type TransportProtocol =
  (typeof TransportProtocol)[keyof typeof TransportProtocol];
export interface PortMapping {
  containerPort?: number;
  hostPort?: number;
  protocol?: TransportProtocol;
  name?: string;
  appProtocol?: ApplicationProtocol;
  containerPortRange?: string;
}
export interface RepositoryCredentials {
  credentialsParameter: string | undefined;
}
export declare const ResourceType: {
  readonly GPU: "GPU";
  readonly INFERENCE_ACCELERATOR: "InferenceAccelerator";
};
export type ResourceType = (typeof ResourceType)[keyof typeof ResourceType];
export interface ResourceRequirement {
  value: string | undefined;
  type: ResourceType | undefined;
}
export interface SystemControl {
  namespace?: string;
  value?: string;
}
export declare const UlimitName: {
  readonly CORE: "core";
  readonly CPU: "cpu";
  readonly DATA: "data";
  readonly FSIZE: "fsize";
  readonly LOCKS: "locks";
  readonly MEMLOCK: "memlock";
  readonly MSGQUEUE: "msgqueue";
  readonly NICE: "nice";
  readonly NOFILE: "nofile";
  readonly NPROC: "nproc";
  readonly RSS: "rss";
  readonly RTPRIO: "rtprio";
  readonly RTTIME: "rttime";
  readonly SIGPENDING: "sigpending";
  readonly STACK: "stack";
};
export type UlimitName = (typeof UlimitName)[keyof typeof UlimitName];
export interface Ulimit {
  name: UlimitName | undefined;
  softLimit: number | undefined;
  hardLimit: number | undefined;
}
export interface VolumeFrom {
  sourceContainer?: string;
  readOnly?: boolean;
}
export interface ContainerDefinition {
  name?: string;
  image?: string;
  repositoryCredentials?: RepositoryCredentials;
  cpu?: number;
  memory?: number;
  memoryReservation?: number;
  links?: string[];
  portMappings?: PortMapping[];
  essential?: boolean;
  entryPoint?: string[];
  command?: string[];
  environment?: KeyValuePair[];
  environmentFiles?: EnvironmentFile[];
  mountPoints?: MountPoint[];
  volumesFrom?: VolumeFrom[];
  linuxParameters?: LinuxParameters;
  secrets?: Secret[];
  dependsOn?: ContainerDependency[];
  startTimeout?: number;
  stopTimeout?: number;
  hostname?: string;
  user?: string;
  workingDirectory?: string;
  disableNetworking?: boolean;
  privileged?: boolean;
  readonlyRootFilesystem?: boolean;
  dnsServers?: string[];
  dnsSearchDomains?: string[];
  extraHosts?: HostEntry[];
  dockerSecurityOptions?: string[];
  interactive?: boolean;
  pseudoTerminal?: boolean;
  dockerLabels?: Record<string, string>;
  ulimits?: Ulimit[];
  logConfiguration?: LogConfiguration;
  healthCheck?: HealthCheck;
  systemControls?: SystemControl[];
  resourceRequirements?: ResourceRequirement[];
  firelensConfiguration?: FirelensConfiguration;
  credentialSpecs?: string[];
}
export interface EphemeralStorage {
  sizeInGiB: number | undefined;
}
export interface InferenceAccelerator {
  deviceName: string | undefined;
  deviceType: string | undefined;
}
export declare const IpcMode: {
  readonly HOST: "host";
  readonly NONE: "none";
  readonly TASK: "task";
};
export type IpcMode = (typeof IpcMode)[keyof typeof IpcMode];
export declare const NetworkMode: {
  readonly AWSVPC: "awsvpc";
  readonly BRIDGE: "bridge";
  readonly HOST: "host";
  readonly NONE: "none";
};
export type NetworkMode = (typeof NetworkMode)[keyof typeof NetworkMode];
export declare const PidMode: {
  readonly HOST: "host";
  readonly TASK: "task";
};
export type PidMode = (typeof PidMode)[keyof typeof PidMode];
export declare const TaskDefinitionPlacementConstraintType: {
  readonly MEMBER_OF: "memberOf";
};
export type TaskDefinitionPlacementConstraintType =
  (typeof TaskDefinitionPlacementConstraintType)[keyof typeof TaskDefinitionPlacementConstraintType];
export interface TaskDefinitionPlacementConstraint {
  type?: TaskDefinitionPlacementConstraintType;
  expression?: string;
}
export declare const ProxyConfigurationType: {
  readonly APPMESH: "APPMESH";
};
export type ProxyConfigurationType =
  (typeof ProxyConfigurationType)[keyof typeof ProxyConfigurationType];
export interface ProxyConfiguration {
  type?: ProxyConfigurationType;
  containerName: string | undefined;
  properties?: KeyValuePair[];
}
export declare const CPUArchitecture: {
  readonly ARM64: "ARM64";
  readonly X86_64: "X86_64";
};
export type CPUArchitecture =
  (typeof CPUArchitecture)[keyof typeof CPUArchitecture];
export declare const OSFamily: {
  readonly LINUX: "LINUX";
  readonly WINDOWS_SERVER_2004_CORE: "WINDOWS_SERVER_2004_CORE";
  readonly WINDOWS_SERVER_2016_FULL: "WINDOWS_SERVER_2016_FULL";
  readonly WINDOWS_SERVER_2019_CORE: "WINDOWS_SERVER_2019_CORE";
  readonly WINDOWS_SERVER_2019_FULL: "WINDOWS_SERVER_2019_FULL";
  readonly WINDOWS_SERVER_2022_CORE: "WINDOWS_SERVER_2022_CORE";
  readonly WINDOWS_SERVER_2022_FULL: "WINDOWS_SERVER_2022_FULL";
  readonly WINDOWS_SERVER_20H2_CORE: "WINDOWS_SERVER_20H2_CORE";
};
export type OSFamily = (typeof OSFamily)[keyof typeof OSFamily];
export interface RuntimePlatform {
  cpuArchitecture?: CPUArchitecture;
  operatingSystemFamily?: OSFamily;
}
export declare const TaskDefinitionStatus: {
  readonly ACTIVE: "ACTIVE";
  readonly DELETE_IN_PROGRESS: "DELETE_IN_PROGRESS";
  readonly INACTIVE: "INACTIVE";
};
export type TaskDefinitionStatus =
  (typeof TaskDefinitionStatus)[keyof typeof TaskDefinitionStatus];
export declare const Scope: {
  readonly SHARED: "shared";
  readonly TASK: "task";
};
export type Scope = (typeof Scope)[keyof typeof Scope];
export interface DockerVolumeConfiguration {
  scope?: Scope;
  autoprovision?: boolean;
  driver?: string;
  driverOpts?: Record<string, string>;
  labels?: Record<string, string>;
}
export declare const EFSAuthorizationConfigIAM: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
};
export type EFSAuthorizationConfigIAM =
  (typeof EFSAuthorizationConfigIAM)[keyof typeof EFSAuthorizationConfigIAM];
export interface EFSAuthorizationConfig {
  accessPointId?: string;
  iam?: EFSAuthorizationConfigIAM;
}
export declare const EFSTransitEncryption: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
};
export type EFSTransitEncryption =
  (typeof EFSTransitEncryption)[keyof typeof EFSTransitEncryption];
export interface EFSVolumeConfiguration {
  fileSystemId: string | undefined;
  rootDirectory?: string;
  transitEncryption?: EFSTransitEncryption;
  transitEncryptionPort?: number;
  authorizationConfig?: EFSAuthorizationConfig;
}
export interface FSxWindowsFileServerAuthorizationConfig {
  credentialsParameter: string | undefined;
  domain: string | undefined;
}
export interface FSxWindowsFileServerVolumeConfiguration {
  fileSystemId: string | undefined;
  rootDirectory: string | undefined;
  authorizationConfig: FSxWindowsFileServerAuthorizationConfig | undefined;
}
export interface HostVolumeProperties {
  sourcePath?: string;
}
export interface Volume {
  name?: string;
  host?: HostVolumeProperties;
  dockerVolumeConfiguration?: DockerVolumeConfiguration;
  efsVolumeConfiguration?: EFSVolumeConfiguration;
  fsxWindowsFileServerVolumeConfiguration?: FSxWindowsFileServerVolumeConfiguration;
  configuredAtLaunch?: boolean;
}
export interface TaskDefinition {
  taskDefinitionArn?: string;
  containerDefinitions?: ContainerDefinition[];
  family?: string;
  taskRoleArn?: string;
  executionRoleArn?: string;
  networkMode?: NetworkMode;
  revision?: number;
  volumes?: Volume[];
  status?: TaskDefinitionStatus;
  requiresAttributes?: Attribute[];
  placementConstraints?: TaskDefinitionPlacementConstraint[];
  compatibilities?: Compatibility[];
  runtimePlatform?: RuntimePlatform;
  requiresCompatibilities?: Compatibility[];
  cpu?: string;
  memory?: string;
  inferenceAccelerators?: InferenceAccelerator[];
  pidMode?: PidMode;
  ipcMode?: IpcMode;
  proxyConfiguration?: ProxyConfiguration;
  registeredAt?: Date;
  deregisteredAt?: Date;
  registeredBy?: string;
  ephemeralStorage?: EphemeralStorage;
}
export interface DeleteTaskDefinitionsResponse {
  taskDefinitions?: TaskDefinition[];
  failures?: Failure[];
}
export interface DeleteTaskSetRequest {
  cluster: string | undefined;
  service: string | undefined;
  taskSet: string | undefined;
  force?: boolean;
}
export interface DeleteTaskSetResponse {
  taskSet?: TaskSet;
}
export declare class TaskSetNotFoundException extends __BaseException {
  readonly name: "TaskSetNotFoundException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<TaskSetNotFoundException, __BaseException>
  );
}
export interface DeregisterContainerInstanceRequest {
  cluster?: string;
  containerInstance: string | undefined;
  force?: boolean;
}
export declare const InstanceHealthCheckState: {
  readonly IMPAIRED: "IMPAIRED";
  readonly INITIALIZING: "INITIALIZING";
  readonly INSUFFICIENT_DATA: "INSUFFICIENT_DATA";
  readonly OK: "OK";
};
export type InstanceHealthCheckState =
  (typeof InstanceHealthCheckState)[keyof typeof InstanceHealthCheckState];
export declare const InstanceHealthCheckType: {
  readonly CONTAINER_RUNTIME: "CONTAINER_RUNTIME";
};
export type InstanceHealthCheckType =
  (typeof InstanceHealthCheckType)[keyof typeof InstanceHealthCheckType];
export interface InstanceHealthCheckResult {
  type?: InstanceHealthCheckType;
  status?: InstanceHealthCheckState;
  lastUpdated?: Date;
  lastStatusChange?: Date;
}
export interface ContainerInstanceHealthStatus {
  overallStatus?: InstanceHealthCheckState;
  details?: InstanceHealthCheckResult[];
}
export interface Resource {
  name?: string;
  type?: string;
  doubleValue?: number;
  longValue?: number;
  integerValue?: number;
  stringSetValue?: string[];
}
export interface VersionInfo {
  agentVersion?: string;
  agentHash?: string;
  dockerVersion?: string;
}
export interface ContainerInstance {
  containerInstanceArn?: string;
  ec2InstanceId?: string;
  capacityProviderName?: string;
  version?: number;
  versionInfo?: VersionInfo;
  remainingResources?: Resource[];
  registeredResources?: Resource[];
  status?: string;
  statusReason?: string;
  agentConnected?: boolean;
  runningTasksCount?: number;
  pendingTasksCount?: number;
  agentUpdateStatus?: AgentUpdateStatus;
  attributes?: Attribute[];
  registeredAt?: Date;
  attachments?: Attachment[];
  tags?: Tag[];
  healthStatus?: ContainerInstanceHealthStatus;
}
export interface DeregisterContainerInstanceResponse {
  containerInstance?: ContainerInstance;
}
export interface DeregisterTaskDefinitionRequest {
  taskDefinition: string | undefined;
}
export interface DeregisterTaskDefinitionResponse {
  taskDefinition?: TaskDefinition;
}
export declare const CapacityProviderField: {
  readonly TAGS: "TAGS";
};
export type CapacityProviderField =
  (typeof CapacityProviderField)[keyof typeof CapacityProviderField];
export interface DescribeCapacityProvidersRequest {
  capacityProviders?: string[];
  include?: CapacityProviderField[];
  maxResults?: number;
  nextToken?: string;
}
export interface DescribeCapacityProvidersResponse {
  capacityProviders?: CapacityProvider[];
  failures?: Failure[];
  nextToken?: string;
}
export declare const ClusterField: {
  readonly ATTACHMENTS: "ATTACHMENTS";
  readonly CONFIGURATIONS: "CONFIGURATIONS";
  readonly SETTINGS: "SETTINGS";
  readonly STATISTICS: "STATISTICS";
  readonly TAGS: "TAGS";
};
export type ClusterField = (typeof ClusterField)[keyof typeof ClusterField];
export interface DescribeClustersRequest {
  clusters?: string[];
  include?: ClusterField[];
}
export interface DescribeClustersResponse {
  clusters?: Cluster[];
  failures?: Failure[];
}
export declare const ContainerInstanceField: {
  readonly CONTAINER_INSTANCE_HEALTH: "CONTAINER_INSTANCE_HEALTH";
  readonly TAGS: "TAGS";
};
export type ContainerInstanceField =
  (typeof ContainerInstanceField)[keyof typeof ContainerInstanceField];
export interface DescribeContainerInstancesRequest {
  cluster?: string;
  containerInstances: string[] | undefined;
  include?: ContainerInstanceField[];
}
export interface DescribeContainerInstancesResponse {
  containerInstances?: ContainerInstance[];
  failures?: Failure[];
}
export declare const ServiceField: {
  readonly TAGS: "TAGS";
};
export type ServiceField = (typeof ServiceField)[keyof typeof ServiceField];
export interface DescribeServicesRequest {
  cluster?: string;
  services: string[] | undefined;
  include?: ServiceField[];
}
export interface DescribeServicesResponse {
  services?: Service[];
  failures?: Failure[];
}
export declare const TaskDefinitionField: {
  readonly TAGS: "TAGS";
};
export type TaskDefinitionField =
  (typeof TaskDefinitionField)[keyof typeof TaskDefinitionField];
export interface DescribeTaskDefinitionRequest {
  taskDefinition: string | undefined;
  include?: TaskDefinitionField[];
}
export interface DescribeTaskDefinitionResponse {
  taskDefinition?: TaskDefinition;
  tags?: Tag[];
}
export declare const TaskField: {
  readonly TAGS: "TAGS";
};
export type TaskField = (typeof TaskField)[keyof typeof TaskField];
export interface DescribeTasksRequest {
  cluster?: string;
  tasks: string[] | undefined;
  include?: TaskField[];
}
export declare const Connectivity: {
  readonly CONNECTED: "CONNECTED";
  readonly DISCONNECTED: "DISCONNECTED";
};
export type Connectivity = (typeof Connectivity)[keyof typeof Connectivity];
export declare const HealthStatus: {
  readonly HEALTHY: "HEALTHY";
  readonly UNHEALTHY: "UNHEALTHY";
  readonly UNKNOWN: "UNKNOWN";
};
export type HealthStatus = (typeof HealthStatus)[keyof typeof HealthStatus];
export declare const ManagedAgentName: {
  readonly ExecuteCommandAgent: "ExecuteCommandAgent";
};
export type ManagedAgentName =
  (typeof ManagedAgentName)[keyof typeof ManagedAgentName];
export interface ManagedAgent {
  lastStartedAt?: Date;
  name?: ManagedAgentName;
  reason?: string;
  lastStatus?: string;
}
export interface NetworkBinding {
  bindIP?: string;
  containerPort?: number;
  hostPort?: number;
  protocol?: TransportProtocol;
  containerPortRange?: string;
  hostPortRange?: string;
}
export interface NetworkInterface {
  attachmentId?: string;
  privateIpv4Address?: string;
  ipv6Address?: string;
}
export interface Container {
  containerArn?: string;
  taskArn?: string;
  name?: string;
  image?: string;
  imageDigest?: string;
  runtimeId?: string;
  lastStatus?: string;
  exitCode?: number;
  reason?: string;
  networkBindings?: NetworkBinding[];
  networkInterfaces?: NetworkInterface[];
  healthStatus?: HealthStatus;
  managedAgents?: ManagedAgent[];
  cpu?: string;
  memory?: string;
  memoryReservation?: string;
  gpuIds?: string[];
}
export interface TaskEphemeralStorage {
  sizeInGiB?: number;
  kmsKeyId?: string;
}
export interface ContainerOverride {
  name?: string;
  command?: string[];
  environment?: KeyValuePair[];
  environmentFiles?: EnvironmentFile[];
  cpu?: number;
  memory?: number;
  memoryReservation?: number;
  resourceRequirements?: ResourceRequirement[];
}
export interface InferenceAcceleratorOverride {
  deviceName?: string;
  deviceType?: string;
}
export interface TaskOverride {
  containerOverrides?: ContainerOverride[];
  cpu?: string;
  inferenceAcceleratorOverrides?: InferenceAcceleratorOverride[];
  executionRoleArn?: string;
  memory?: string;
  taskRoleArn?: string;
  ephemeralStorage?: EphemeralStorage;
}
export declare const TaskStopCode: {
  readonly ESSENTIAL_CONTAINER_EXITED: "EssentialContainerExited";
  readonly SERVICE_SCHEDULER_INITIATED: "ServiceSchedulerInitiated";
  readonly SPOT_INTERRUPTION: "SpotInterruption";
  readonly TASK_FAILED_TO_START: "TaskFailedToStart";
  readonly TERMINATION_NOTICE: "TerminationNotice";
  readonly USER_INITIATED: "UserInitiated";
};
export type TaskStopCode = (typeof TaskStopCode)[keyof typeof TaskStopCode];
export interface Task {
  attachments?: Attachment[];
  attributes?: Attribute[];
  availabilityZone?: string;
  capacityProviderName?: string;
  clusterArn?: string;
  connectivity?: Connectivity;
  connectivityAt?: Date;
  containerInstanceArn?: string;
  containers?: Container[];
  cpu?: string;
  createdAt?: Date;
  desiredStatus?: string;
  enableExecuteCommand?: boolean;
  executionStoppedAt?: Date;
  group?: string;
  healthStatus?: HealthStatus;
  inferenceAccelerators?: InferenceAccelerator[];
  lastStatus?: string;
  launchType?: LaunchType;
  memory?: string;
  overrides?: TaskOverride;
  platformVersion?: string;
  platformFamily?: string;
  pullStartedAt?: Date;
  pullStoppedAt?: Date;
  startedAt?: Date;
  startedBy?: string;
  stopCode?: TaskStopCode;
  stoppedAt?: Date;
  stoppedReason?: string;
  stoppingAt?: Date;
  tags?: Tag[];
  taskArn?: string;
  taskDefinitionArn?: string;
  version?: number;
  ephemeralStorage?: EphemeralStorage;
  fargateEphemeralStorage?: TaskEphemeralStorage;
}
export interface DescribeTasksResponse {
  tasks?: Task[];
  failures?: Failure[];
}
export declare const TaskSetField: {
  readonly TAGS: "TAGS";
};
export type TaskSetField = (typeof TaskSetField)[keyof typeof TaskSetField];
export interface DescribeTaskSetsRequest {
  cluster: string | undefined;
  service: string | undefined;
  taskSets?: string[];
  include?: TaskSetField[];
}
export interface DescribeTaskSetsResponse {
  taskSets?: TaskSet[];
  failures?: Failure[];
}
export interface DiscoverPollEndpointRequest {
  containerInstance?: string;
  cluster?: string;
}
export interface DiscoverPollEndpointResponse {
  endpoint?: string;
  telemetryEndpoint?: string;
  serviceConnectEndpoint?: string;
}
export interface ExecuteCommandRequest {
  cluster?: string;
  container?: string;
  command: string | undefined;
  interactive: boolean | undefined;
  task: string | undefined;
}
export interface Session {
  sessionId?: string;
  streamUrl?: string;
  tokenValue?: string;
}
export interface ExecuteCommandResponse {
  clusterArn?: string;
  containerArn?: string;
  containerName?: string;
  interactive?: boolean;
  session?: Session;
  taskArn?: string;
}
export declare class TargetNotConnectedException extends __BaseException {
  readonly name: "TargetNotConnectedException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<TargetNotConnectedException, __BaseException>
  );
}
export interface GetTaskProtectionRequest {
  cluster: string | undefined;
  tasks?: string[];
}
export interface ProtectedTask {
  taskArn?: string;
  protectionEnabled?: boolean;
  expirationDate?: Date;
}
export interface GetTaskProtectionResponse {
  protectedTasks?: ProtectedTask[];
  failures?: Failure[];
}
export declare class ResourceNotFoundException extends __BaseException {
  readonly name: "ResourceNotFoundException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<ResourceNotFoundException, __BaseException>
  );
}
export interface ListAccountSettingsRequest {
  name?: SettingName;
  value?: string;
  principalArn?: string;
  effectiveSettings?: boolean;
  nextToken?: string;
  maxResults?: number;
}
export interface ListAccountSettingsResponse {
  settings?: Setting[];
  nextToken?: string;
}
export interface ListAttributesRequest {
  cluster?: string;
  targetType: TargetType | undefined;
  attributeName?: string;
  attributeValue?: string;
  nextToken?: string;
  maxResults?: number;
}
export interface ListAttributesResponse {
  attributes?: Attribute[];
  nextToken?: string;
}
export interface ListClustersRequest {
  nextToken?: string;
  maxResults?: number;
}
export interface ListClustersResponse {
  clusterArns?: string[];
  nextToken?: string;
}
export declare const ContainerInstanceStatus: {
  readonly ACTIVE: "ACTIVE";
  readonly DEREGISTERING: "DEREGISTERING";
  readonly DRAINING: "DRAINING";
  readonly REGISTERING: "REGISTERING";
  readonly REGISTRATION_FAILED: "REGISTRATION_FAILED";
};
export type ContainerInstanceStatus =
  (typeof ContainerInstanceStatus)[keyof typeof ContainerInstanceStatus];
export interface ListContainerInstancesRequest {
  cluster?: string;
  filter?: string;
  nextToken?: string;
  maxResults?: number;
  status?: ContainerInstanceStatus;
}
export interface ListContainerInstancesResponse {
  containerInstanceArns?: string[];
  nextToken?: string;
}
export interface ListServicesRequest {
  cluster?: string;
  nextToken?: string;
  maxResults?: number;
  launchType?: LaunchType;
  schedulingStrategy?: SchedulingStrategy;
}
export interface ListServicesResponse {
  serviceArns?: string[];
  nextToken?: string;
}
export interface ListServicesByNamespaceRequest {
  namespace: string | undefined;
  nextToken?: string;
  maxResults?: number;
}
export interface ListServicesByNamespaceResponse {
  serviceArns?: string[];
  nextToken?: string;
}
export interface ListTagsForResourceRequest {
  resourceArn: string | undefined;
}
export interface ListTagsForResourceResponse {
  tags?: Tag[];
}
export declare const TaskDefinitionFamilyStatus: {
  readonly ACTIVE: "ACTIVE";
  readonly ALL: "ALL";
  readonly INACTIVE: "INACTIVE";
};
export type TaskDefinitionFamilyStatus =
  (typeof TaskDefinitionFamilyStatus)[keyof typeof TaskDefinitionFamilyStatus];
export interface ListTaskDefinitionFamiliesRequest {
  familyPrefix?: string;
  status?: TaskDefinitionFamilyStatus;
  nextToken?: string;
  maxResults?: number;
}
export interface ListTaskDefinitionFamiliesResponse {
  families?: string[];
  nextToken?: string;
}
export declare const SortOrder: {
  readonly ASC: "ASC";
  readonly DESC: "DESC";
};
export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder];
export interface ListTaskDefinitionsRequest {
  familyPrefix?: string;
  status?: TaskDefinitionStatus;
  sort?: SortOrder;
  nextToken?: string;
  maxResults?: number;
}
export interface ListTaskDefinitionsResponse {
  taskDefinitionArns?: string[];
  nextToken?: string;
}
export declare const DesiredStatus: {
  readonly PENDING: "PENDING";
  readonly RUNNING: "RUNNING";
  readonly STOPPED: "STOPPED";
};
export type DesiredStatus = (typeof DesiredStatus)[keyof typeof DesiredStatus];
export interface ListTasksRequest {
  cluster?: string;
  containerInstance?: string;
  family?: string;
  nextToken?: string;
  maxResults?: number;
  startedBy?: string;
  serviceName?: string;
  desiredStatus?: DesiredStatus;
  launchType?: LaunchType;
}
export interface ListTasksResponse {
  taskArns?: string[];
  nextToken?: string;
}
export interface PutAccountSettingRequest {
  name: SettingName | undefined;
  value: string | undefined;
  principalArn?: string;
}
export interface PutAccountSettingResponse {
  setting?: Setting;
}
export interface PutAccountSettingDefaultRequest {
  name: SettingName | undefined;
  value: string | undefined;
}
export interface PutAccountSettingDefaultResponse {
  setting?: Setting;
}
export declare class AttributeLimitExceededException extends __BaseException {
  readonly name: "AttributeLimitExceededException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      AttributeLimitExceededException,
      __BaseException
    >
  );
}
export interface PutAttributesRequest {
  cluster?: string;
  attributes: Attribute[] | undefined;
}
export interface PutAttributesResponse {
  attributes?: Attribute[];
}
export interface PutClusterCapacityProvidersRequest {
  cluster: string | undefined;
  capacityProviders: string[] | undefined;
  defaultCapacityProviderStrategy: CapacityProviderStrategyItem[] | undefined;
}
export interface PutClusterCapacityProvidersResponse {
  cluster?: Cluster;
}
export declare class ResourceInUseException extends __BaseException {
  readonly name: "ResourceInUseException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<ResourceInUseException, __BaseException>
  );
}
export declare const PlatformDeviceType: {
  readonly GPU: "GPU";
};
export type PlatformDeviceType =
  (typeof PlatformDeviceType)[keyof typeof PlatformDeviceType];
export interface PlatformDevice {
  id: string | undefined;
  type: PlatformDeviceType | undefined;
}
export interface RegisterContainerInstanceRequest {
  cluster?: string;
  instanceIdentityDocument?: string;
  instanceIdentityDocumentSignature?: string;
  totalResources?: Resource[];
  versionInfo?: VersionInfo;
  containerInstanceArn?: string;
  attributes?: Attribute[];
  platformDevices?: PlatformDevice[];
  tags?: Tag[];
}
export interface RegisterContainerInstanceResponse {
  containerInstance?: ContainerInstance;
}
export interface RegisterTaskDefinitionRequest {
  family: string | undefined;
  taskRoleArn?: string;
  executionRoleArn?: string;
  networkMode?: NetworkMode;
  containerDefinitions: ContainerDefinition[] | undefined;
  volumes?: Volume[];
  placementConstraints?: TaskDefinitionPlacementConstraint[];
  requiresCompatibilities?: Compatibility[];
  cpu?: string;
  memory?: string;
  tags?: Tag[];
  pidMode?: PidMode;
  ipcMode?: IpcMode;
  proxyConfiguration?: ProxyConfiguration;
  inferenceAccelerators?: InferenceAccelerator[];
  ephemeralStorage?: EphemeralStorage;
  runtimePlatform?: RuntimePlatform;
}
export interface RegisterTaskDefinitionResponse {
  taskDefinition?: TaskDefinition;
  tags?: Tag[];
}
export declare class BlockedException extends __BaseException {
  readonly name: "BlockedException";
  readonly $fault: "client";
  constructor(opts: __ExceptionOptionType<BlockedException, __BaseException>);
}
export declare class ConflictException extends __BaseException {
  readonly name: "ConflictException";
  readonly $fault: "client";
  resourceIds?: string[];
  constructor(opts: __ExceptionOptionType<ConflictException, __BaseException>);
}
export interface TaskManagedEBSVolumeTerminationPolicy {
  deleteOnTermination: boolean | undefined;
}
export interface TaskManagedEBSVolumeConfiguration {
  encrypted?: boolean;
  kmsKeyId?: string;
  volumeType?: string;
  sizeInGiB?: number;
  snapshotId?: string;
  iops?: number;
  throughput?: number;
  tagSpecifications?: EBSTagSpecification[];
  roleArn: string | undefined;
  terminationPolicy?: TaskManagedEBSVolumeTerminationPolicy;
  filesystemType?: TaskFilesystemType;
}
export interface TaskVolumeConfiguration {
  name: string | undefined;
  managedEBSVolume?: TaskManagedEBSVolumeConfiguration;
}
export interface RunTaskRequest {
  capacityProviderStrategy?: CapacityProviderStrategyItem[];
  cluster?: string;
  count?: number;
  enableECSManagedTags?: boolean;
  enableExecuteCommand?: boolean;
  group?: string;
  launchType?: LaunchType;
  networkConfiguration?: NetworkConfiguration;
  overrides?: TaskOverride;
  placementConstraints?: PlacementConstraint[];
  placementStrategy?: PlacementStrategy[];
  platformVersion?: string;
  propagateTags?: PropagateTags;
  referenceId?: string;
  startedBy?: string;
  tags?: Tag[];
  taskDefinition: string | undefined;
  clientToken?: string;
  volumeConfigurations?: TaskVolumeConfiguration[];
}
export interface RunTaskResponse {
  tasks?: Task[];
  failures?: Failure[];
}
export interface StartTaskRequest {
  cluster?: string;
  containerInstances: string[] | undefined;
  enableECSManagedTags?: boolean;
  enableExecuteCommand?: boolean;
  group?: string;
  networkConfiguration?: NetworkConfiguration;
  overrides?: TaskOverride;
  propagateTags?: PropagateTags;
  referenceId?: string;
  startedBy?: string;
  tags?: Tag[];
  taskDefinition: string | undefined;
  volumeConfigurations?: TaskVolumeConfiguration[];
}
export interface StartTaskResponse {
  tasks?: Task[];
  failures?: Failure[];
}
export interface StopTaskRequest {
  cluster?: string;
  task: string | undefined;
  reason?: string;
}
export interface StopTaskResponse {
  task?: Task;
}
export interface AttachmentStateChange {
  attachmentArn: string | undefined;
  status: string | undefined;
}
export interface SubmitAttachmentStateChangesRequest {
  cluster?: string;
  attachments: AttachmentStateChange[] | undefined;
}
export interface SubmitAttachmentStateChangesResponse {
  acknowledgment?: string;
}
export interface SubmitContainerStateChangeRequest {
  cluster?: string;
  task?: string;
  containerName?: string;
  runtimeId?: string;
  status?: string;
  exitCode?: number;
  reason?: string;
  networkBindings?: NetworkBinding[];
}
export interface SubmitContainerStateChangeResponse {
  acknowledgment?: string;
}
export interface ContainerStateChange {
  containerName?: string;
  imageDigest?: string;
  runtimeId?: string;
  exitCode?: number;
  networkBindings?: NetworkBinding[];
  reason?: string;
  status?: string;
}
export interface ManagedAgentStateChange {
  containerName: string | undefined;
  managedAgentName: ManagedAgentName | undefined;
  status: string | undefined;
  reason?: string;
}
export interface SubmitTaskStateChangeRequest {
  cluster?: string;
  task?: string;
  status?: string;
  reason?: string;
  containers?: ContainerStateChange[];
  attachments?: AttachmentStateChange[];
  managedAgents?: ManagedAgentStateChange[];
  pullStartedAt?: Date;
  pullStoppedAt?: Date;
  executionStoppedAt?: Date;
}
export interface SubmitTaskStateChangeResponse {
  acknowledgment?: string;
}
export interface TagResourceRequest {
  resourceArn: string | undefined;
  tags: Tag[] | undefined;
}
export interface TagResourceResponse {}
export interface UntagResourceRequest {
  resourceArn: string | undefined;
  tagKeys: string[] | undefined;
}
export interface UntagResourceResponse {}
export interface AutoScalingGroupProviderUpdate {
  managedScaling?: ManagedScaling;
  managedTerminationProtection?: ManagedTerminationProtection;
  managedDraining?: ManagedDraining;
}
export interface UpdateCapacityProviderRequest {
  name: string | undefined;
  autoScalingGroupProvider: AutoScalingGroupProviderUpdate | undefined;
}
export interface UpdateCapacityProviderResponse {
  capacityProvider?: CapacityProvider;
}
export interface UpdateClusterRequest {
  cluster: string | undefined;
  settings?: ClusterSetting[];
  configuration?: ClusterConfiguration;
  serviceConnectDefaults?: ClusterServiceConnectDefaultsRequest;
}
export interface UpdateClusterResponse {
  cluster?: Cluster;
}
export interface UpdateClusterSettingsRequest {
  cluster: string | undefined;
  settings: ClusterSetting[] | undefined;
}
export interface UpdateClusterSettingsResponse {
  cluster?: Cluster;
}
export declare class MissingVersionException extends __BaseException {
  readonly name: "MissingVersionException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<MissingVersionException, __BaseException>
  );
}
export declare class NoUpdateAvailableException extends __BaseException {
  readonly name: "NoUpdateAvailableException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<NoUpdateAvailableException, __BaseException>
  );
}
export interface UpdateContainerAgentRequest {
  cluster?: string;
  containerInstance: string | undefined;
}
export interface UpdateContainerAgentResponse {
  containerInstance?: ContainerInstance;
}
export interface UpdateContainerInstancesStateRequest {
  cluster?: string;
  containerInstances: string[] | undefined;
  status: ContainerInstanceStatus | undefined;
}
export interface UpdateContainerInstancesStateResponse {
  containerInstances?: ContainerInstance[];
  failures?: Failure[];
}
export interface UpdateServiceRequest {
  cluster?: string;
  service: string | undefined;
  desiredCount?: number;
  taskDefinition?: string;
  capacityProviderStrategy?: CapacityProviderStrategyItem[];
  deploymentConfiguration?: DeploymentConfiguration;
  networkConfiguration?: NetworkConfiguration;
  placementConstraints?: PlacementConstraint[];
  placementStrategy?: PlacementStrategy[];
  platformVersion?: string;
  forceNewDeployment?: boolean;
  healthCheckGracePeriodSeconds?: number;
  enableExecuteCommand?: boolean;
  enableECSManagedTags?: boolean;
  loadBalancers?: LoadBalancer[];
  propagateTags?: PropagateTags;
  serviceRegistries?: ServiceRegistry[];
  serviceConnectConfiguration?: ServiceConnectConfiguration;
  volumeConfigurations?: ServiceVolumeConfiguration[];
}
export interface UpdateServiceResponse {
  service?: Service;
}
export interface UpdateServicePrimaryTaskSetRequest {
  cluster: string | undefined;
  service: string | undefined;
  primaryTaskSet: string | undefined;
}
export interface UpdateServicePrimaryTaskSetResponse {
  taskSet?: TaskSet;
}
export interface UpdateTaskProtectionRequest {
  cluster: string | undefined;
  tasks: string[] | undefined;
  protectionEnabled: boolean | undefined;
  expiresInMinutes?: number;
}
export interface UpdateTaskProtectionResponse {
  protectedTasks?: ProtectedTask[];
  failures?: Failure[];
}
export interface UpdateTaskSetRequest {
  cluster: string | undefined;
  service: string | undefined;
  taskSet: string | undefined;
  scale: Scale | undefined;
}
export interface UpdateTaskSetResponse {
  taskSet?: TaskSet;
}
export declare const SessionFilterSensitiveLog: (obj: Session) => any;
export declare const ExecuteCommandResponseFilterSensitiveLog: (
  obj: ExecuteCommandResponse
) => any;
