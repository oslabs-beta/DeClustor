var he=(l=>(l.uninitialized="uninitialized",l.pending="pending",l.fulfilled="fulfilled",l.rejected="rejected",l))(he||{});function Ee(e){return{status:e,isUninitialized:e==="uninitialized",isLoading:e==="pending",isSuccess:e==="fulfilled",isError:e==="rejected"}}function Me(e){return new RegExp("(^|:)//").test(e)}var yt=e=>e.replace(/\/$/,""),dt=e=>e.replace(/^\//,"");function ke(e,r){if(!e)return r;if(!r)return e;if(Me(r))return r;let c=e.endsWith("/")||!r.startsWith("?")?"/":"";return e=yt(e),r=dt(r),`${e}${c}${r}`}var Qe=e=>[].concat(...e);function Be(){return typeof navigator>"u"||navigator.onLine===void 0?!0:navigator.onLine}function ve(){return typeof document>"u"?!0:document.visibilityState!=="hidden"}import{createAction as H,createSlice as V,createSelector as Pe,createAsyncThunk as Re,combineReducers as Fe,createNextState as ne,isAnyOf as re,isAllOf as ue,isAction as we,isPending as ye,isRejected as J,isFulfilled as q,isRejectedWithValue as G,isAsyncThunkAction as xe,prepareAutoBatched as Y,SHOULD_AUTOBATCH as ie,isPlainObject as L,nanoid as Ce}from"@reduxjs/toolkit";var Ie=L;function de(e,r){if(e===r||!(Ie(e)&&Ie(r)||Array.isArray(e)&&Array.isArray(r)))return r;let c=Object.keys(r),g=Object.keys(e),l=c.length===g.length,Q=Array.isArray(r)?[]:{};for(let x of c)Q[x]=de(e[x],r[x]),l&&(l=e[x]===Q[x]);return l?e:Q}var Oe=(...e)=>fetch(...e),pt=e=>e.status>=200&&e.status<=299,ct=e=>/ion\/(vnd\.api\+)?json/.test(e.get("content-type")||"");function qe(e){if(!L(e))return e;let r={...e};for(let[c,g]of Object.entries(r))g===void 0&&delete r[c];return r}function lt({baseUrl:e,prepareHeaders:r=d=>d,fetchFn:c=Oe,paramsSerializer:g,isJsonContentType:l=ct,jsonContentType:Q="application/json",jsonReplacer:x,timeout:E,responseHandler:M,validateStatus:f,...S}={}){return typeof fetch>"u"&&c===Oe&&console.warn("Warning: `fetch` is not available. Please supply a custom `fetchFn` property to use `fetchBaseQuery` on SSR environments."),async(n,t)=>{let{signal:m,getState:R,extra:y,endpoint:u,forced:o,type:a}=t,i,{url:s,headers:T=new Headers(S.headers),params:p=void 0,responseHandler:h=M??"json",validateStatus:b=f??pt,timeout:A=E,...k}=typeof n=="string"?{url:n}:n,D={...S,signal:m,...k};T=new Headers(qe(T)),D.headers=await r(T,{getState:R,extra:y,endpoint:u,forced:o,type:a})||T;let B=P=>typeof P=="object"&&(L(P)||Array.isArray(P)||typeof P.toJSON=="function");if(!D.headers.has("content-type")&&B(D.body)&&D.headers.set("content-type",Q),B(D.body)&&l(D.headers)&&(D.body=JSON.stringify(D.body,x)),p){let P=~s.indexOf("?")?"&":"?",F=g?g(p):new URLSearchParams(qe(p));s+=P+F}s=ke(e,s);let v=new Request(s,D);i={request:new Request(s,D)};let I,N=!1,C=A&&setTimeout(()=>{N=!0,t.abort()},A);try{I=await c(v)}catch(P){return{error:{status:N?"TIMEOUT_ERROR":"FETCH_ERROR",error:String(P)},meta:i}}finally{C&&clearTimeout(C)}let K=I.clone();i.response=K;let O,te="";try{let P;if(await Promise.all([d(I,h).then(F=>O=F,F=>P=F),K.text().then(F=>te=F,()=>{})]),P)throw P}catch(P){return{error:{status:"PARSING_ERROR",originalStatus:I.status,data:te,error:String(P)},meta:i}}return b(I,O)?{data:O,meta:i}:{error:{status:I.status,data:O},meta:i}};async function d(n,t){if(typeof t=="function")return t(n);if(t==="content-type"&&(t=l(n.headers)?"json":"text"),t==="json"){let m=await n.text();return m.length?JSON.parse(m):null}return n.text()}}var j=class{constructor(r,c=void 0){this.value=r;this.meta=c}};async function ft(e=0,r=5){let c=Math.min(e,r),g=~~((Math.random()+.4)*(300<<c));await new Promise(l=>setTimeout(Q=>l(Q),g))}function mt(e){throw Object.assign(new j({error:e}),{throwImmediately:!0})}var Ne={},gt=(e,r)=>async(c,g,l)=>{let Q=[5,(r||Ne).maxRetries,(l||Ne).maxRetries].filter(S=>S!==void 0),[x]=Q.slice(-1),M={maxRetries:x,backoff:ft,retryCondition:(S,d,{attempt:n})=>n<=x,...r,...l},f=0;for(;;)try{let S=await e(c,g,l);if(S.error)throw new j(S);return S}catch(S){if(f++,S.throwImmediately){if(S instanceof j)return S.value;throw S}if(S instanceof j&&!M.retryCondition(S.value.error,c,{attempt:f,baseQueryApi:g,extraOptions:l}))return S.value;await M.backoff(f,M.maxRetries)}},Tt=Object.assign(gt,{fail:mt});var z=H("__rtkq/focused"),X=H("__rtkq/unfocused"),W=H("__rtkq/online"),Z=H("__rtkq/offline"),Se=!1;function ht(e,r){function c(){let g=()=>e(z()),l=()=>e(X()),Q=()=>e(W()),x=()=>e(Z()),E=()=>{window.document.visibilityState==="visible"?g():l()};return Se||typeof window<"u"&&window.addEventListener&&(window.addEventListener("visibilitychange",E,!1),window.addEventListener("focus",g,!1),window.addEventListener("online",Q,!1),window.addEventListener("offline",x,!1),Se=!0),()=>{window.removeEventListener("focus",g),window.removeEventListener("visibilitychange",E),window.removeEventListener("online",Q),window.removeEventListener("offline",x),Se=!1}}return r?r(e,{onFocus:z,onFocusLost:X,onOffline:Z,onOnline:W}):c()}function ce(e){return e.type==="query"}function Ke(e){return e.type==="mutation"}function oe(e,r,c,g,l,Q){return Qt(e)?e(r,c,g,l).map(pe).map(Q):Array.isArray(e)?e.map(pe).map(Q):[]}function Qt(e){return typeof e=="function"}function pe(e){return typeof e=="string"?{type:e}:e}import"@reduxjs/toolkit";function Ae(e){return e!=null}function U(e){let r=0;for(let c in e)r++;return r}function je(e,r){return e.catch(r)}var ee=Symbol("forceQueryFn"),ae=e=>typeof e[ee]=="function";function Ue({serializeQueryArgs:e,queryThunk:r,mutationThunk:c,api:g,context:l}){let Q=new Map,x=new Map,{unsubscribeQueryResult:E,removeMutationResult:M,updateSubscriptionOptions:f}=g.internalActions;return{buildInitiateQuery:R,buildInitiateMutation:y,getRunningQueryThunk:S,getRunningMutationThunk:d,getRunningQueriesThunk:n,getRunningMutationsThunk:t};function S(u,o){return a=>{let i=l.endpointDefinitions[u],s=e({queryArgs:o,endpointDefinition:i,endpointName:u});return Q.get(a)?.[s]}}function d(u,o){return a=>x.get(a)?.[o]}function n(){return u=>Object.values(Q.get(u)||{}).filter(Ae)}function t(){return u=>Object.values(x.get(u)||{}).filter(Ae)}function m(u){}function R(u,o){let a=(i,{subscribe:s=!0,forceRefetch:T,subscriptionOptions:p,[ee]:h,...b}={})=>(A,k)=>{let D=e({queryArgs:i,endpointDefinition:o,endpointName:u}),B=r({...b,type:"query",subscribe:s,forceRefetch:T,subscriptionOptions:p,endpointName:u,originalArgs:i,queryCacheKey:D,[ee]:h}),v=g.endpoints[u].select(i),w=A(B),I=v(k());let{requestId:N,abort:C}=w,K=I.requestId!==N,O=Q.get(A)?.[D],te=()=>v(k()),P=Object.assign(h?w.then(te):K&&!O?Promise.resolve(I):Promise.all([O,w]).then(te),{arg:i,requestId:N,subscriptionOptions:p,queryCacheKey:D,abort:C,async unwrap(){let F=await P;if(F.isError)throw F.error;return F.data},refetch:()=>A(a(i,{subscribe:!1,forceRefetch:!0})),unsubscribe(){s&&A(E({queryCacheKey:D,requestId:N}))},updateSubscriptionOptions(F){P.subscriptionOptions=F,A(f({endpointName:u,requestId:N,queryCacheKey:D,options:F}))}});if(!O&&!K&&!h){let F=Q.get(A)||{};F[D]=P,Q.set(A,F),P.then(()=>{delete F[D],U(F)||Q.delete(A)})}return P};return a}function y(u){return(o,{track:a=!0,fixedCacheKey:i}={})=>(s,T)=>{let p=c({type:"mutation",endpointName:u,originalArgs:o,track:a,fixedCacheKey:i}),h=s(p);let{requestId:b,abort:A,unwrap:k}=h,D=je(h.unwrap().then(I=>({data:I})),I=>({error:I})),B=()=>{s(M({requestId:b,fixedCacheKey:i}))},v=Object.assign(D,{arg:h.arg,requestId:b,abort:A,unwrap:k,reset:B}),w=x.get(s)||{};return x.set(s,w),w[b]=v,v.then(()=>{delete w[b],U(w)||x.delete(s)}),i&&(w[i]=v,v.then(()=>{w[i]===v&&(delete w[i],U(w)||x.delete(s))})),v}}}import{isDraftable as Rt,produceWithPatches as xt}from"immer";function He(e){return e}function _e({reducerPath:e,baseQuery:r,context:{endpointDefinitions:c},serializeQueryArgs:g,api:l,assertTagType:Q}){let x=(o,a,i,s)=>(T,p)=>{let h=c[o],b=g({queryArgs:a,endpointDefinition:h,endpointName:o});if(T(l.internalActions.queryResultPatched({queryCacheKey:b,patches:i})),!s)return;let A=l.endpoints[o].select(a)(p()),k=oe(h.providesTags,A.data,void 0,a,{},Q);T(l.internalActions.updateProvidedBy({queryCacheKey:b,providedTags:k}))},E=(o,a,i,s=!0)=>(T,p)=>{let b=l.endpoints[o].select(a)(p()),A={patches:[],inversePatches:[],undo:()=>T(l.util.patchQueryData(o,a,A.inversePatches,s))};if(b.status==="uninitialized")return A;let k;if("data"in b)if(Rt(b.data)){let[D,B,v]=xt(b.data,i);A.patches.push(...B),A.inversePatches.push(...v),k=D}else k=i(b.data),A.patches.push({op:"replace",path:[],value:k}),A.inversePatches.push({op:"replace",path:[],value:b.data});return A.patches.length===0||T(l.util.patchQueryData(o,a,A.patches,s)),A},M=(o,a,i)=>s=>s(l.endpoints[o].initiate(a,{subscribe:!1,forceRefetch:!0,[ee]:()=>({data:i})})),f=async(o,{signal:a,abort:i,rejectWithValue:s,fulfillWithValue:T,dispatch:p,getState:h,extra:b})=>{let A=c[o.endpointName];try{let k=He,D,B={signal:a,abort:i,dispatch:p,getState:h,extra:b,endpoint:o.endpointName,type:o.type,forced:o.type==="query"?S(o,h()):void 0},v=o.type==="query"?o[ee]:void 0;if(v?D=v():A.query?(D=await r(A.query(o.originalArgs),B,A.extraOptions),A.transformResponse&&(k=A.transformResponse)):D=await A.queryFn(o.originalArgs,B,A.extraOptions,w=>r(w,B,A.extraOptions)),typeof process<"u",D.error)throw new j(D.error,D.meta);return T(await k(D.data,D.meta,o.originalArgs),{fulfilledTimeStamp:Date.now(),baseQueryMeta:D.meta,[ie]:!0})}catch(k){let D=k;if(D instanceof j){let B=He;A.query&&A.transformErrorResponse&&(B=A.transformErrorResponse);try{return s(await B(D.value,D.meta,o.originalArgs),{baseQueryMeta:D.meta,[ie]:!0})}catch(v){D=v}}throw typeof process<"u",console.error(D),D}};function S(o,a){let i=a[e]?.queries?.[o.queryCacheKey],s=a[e]?.config.refetchOnMountOrArgChange,T=i?.fulfilledTimeStamp,p=o.forceRefetch??(o.subscribe&&s);return p?p===!0||(Number(new Date)-Number(T))/1e3>=p:!1}let d=Re(`${e}/executeQuery`,f,{getPendingMeta(){return{startedTimeStamp:Date.now(),[ie]:!0}},condition(o,{getState:a}){let i=a(),s=i[e]?.queries?.[o.queryCacheKey],T=s?.fulfilledTimeStamp,p=o.originalArgs,h=s?.originalArgs,b=c[o.endpointName];return ae(o)?!0:s?.status==="pending"?!1:S(o,i)||ce(b)&&b?.forceRefetch?.({currentArg:p,previousArg:h,endpointState:s,state:i})?!0:!T},dispatchConditionRejection:!0}),n=Re(`${e}/executeMutation`,f,{getPendingMeta(){return{startedTimeStamp:Date.now(),[ie]:!0}}}),t=o=>"force"in o,m=o=>"ifOlderThan"in o,R=(o,a,i)=>(s,T)=>{let p=t(i)&&i.force,h=m(i)&&i.ifOlderThan,b=(k=!0)=>{let D={forceRefetch:k,isPrefetch:!0};return l.endpoints[o].initiate(a,D)},A=l.endpoints[o].select(a)(T());if(p)s(b());else if(h){let k=A?.fulfilledTimeStamp;if(!k){s(b());return}(Number(new Date)-Number(new Date(k)))/1e3>=h&&s(b())}else s(b(!1))};function y(o){return a=>a?.meta?.arg?.endpointName===o}function u(o,a){return{matchPending:ue(ye(o),y(a)),matchFulfilled:ue(q(o),y(a)),matchRejected:ue(J(o),y(a))}}return{queryThunk:d,mutationThunk:n,prefetch:R,updateQueryData:E,upsertQueryData:M,patchQueryData:x,buildMatchThunkActions:u}}function le(e,r,c,g){return oe(c[e.meta.arg.endpointName][r],q(e)?e.payload:void 0,G(e)?e.payload:void 0,e.meta.arg.originalArgs,"baseQueryMeta"in e.meta?e.meta.baseQueryMeta:void 0,g)}import{isDraft as St}from"immer";import{applyPatches as Le,original as At}from"immer";function fe(e,r,c){let g=e[r];g&&c(g)}function $(e){return("arg"in e?e.arg.fixedCacheKey:e.fixedCacheKey)??e.requestId}function ze(e,r,c){let g=e[$(r)];g&&c(g)}var se={};function We({reducerPath:e,queryThunk:r,mutationThunk:c,context:{endpointDefinitions:g,apiUid:l,extractRehydrationInfo:Q,hasRehydrationInfo:x},assertTagType:E,config:M}){let f=H(`${e}/resetApiState`),S=V({name:`${e}/queries`,initialState:se,reducers:{removeQueryResult:{reducer(a,{payload:{queryCacheKey:i}}){delete a[i]},prepare:Y()},queryResultPatched:{reducer(a,{payload:{queryCacheKey:i,patches:s}}){fe(a,i,T=>{T.data=Le(T.data,s.concat())})},prepare:Y()}},extraReducers(a){a.addCase(r.pending,(i,{meta:s,meta:{arg:T}})=>{let p=ae(T);i[T.queryCacheKey]??={status:"uninitialized",endpointName:T.endpointName},fe(i,T.queryCacheKey,h=>{h.status="pending",h.requestId=p&&h.requestId?h.requestId:s.requestId,T.originalArgs!==void 0&&(h.originalArgs=T.originalArgs),h.startedTimeStamp=s.startedTimeStamp})}).addCase(r.fulfilled,(i,{meta:s,payload:T})=>{fe(i,s.arg.queryCacheKey,p=>{if(p.requestId!==s.requestId&&!ae(s.arg))return;let{merge:h}=g[s.arg.endpointName];if(p.status="fulfilled",h)if(p.data!==void 0){let{fulfilledTimeStamp:b,arg:A,baseQueryMeta:k,requestId:D}=s,B=ne(p.data,v=>h(v,T,{arg:A.originalArgs,baseQueryMeta:k,fulfilledTimeStamp:b,requestId:D}));p.data=B}else p.data=T;else p.data=g[s.arg.endpointName].structuralSharing??!0?de(St(p.data)?At(p.data):p.data,T):T;delete p.error,p.fulfilledTimeStamp=s.fulfilledTimeStamp})}).addCase(r.rejected,(i,{meta:{condition:s,arg:T,requestId:p},error:h,payload:b})=>{fe(i,T.queryCacheKey,A=>{if(!s){if(A.requestId!==p)return;A.status="rejected",A.error=b??h}})}).addMatcher(x,(i,s)=>{let{queries:T}=Q(s);for(let[p,h]of Object.entries(T))(h?.status==="fulfilled"||h?.status==="rejected")&&(i[p]=h)})}}),d=V({name:`${e}/mutations`,initialState:se,reducers:{removeMutationResult:{reducer(a,{payload:i}){let s=$(i);s in a&&delete a[s]},prepare:Y()}},extraReducers(a){a.addCase(c.pending,(i,{meta:s,meta:{requestId:T,arg:p,startedTimeStamp:h}})=>{p.track&&(i[$(s)]={requestId:T,status:"pending",endpointName:p.endpointName,startedTimeStamp:h})}).addCase(c.fulfilled,(i,{payload:s,meta:T})=>{T.arg.track&&ze(i,T,p=>{p.requestId===T.requestId&&(p.status="fulfilled",p.data=s,p.fulfilledTimeStamp=T.fulfilledTimeStamp)})}).addCase(c.rejected,(i,{payload:s,error:T,meta:p})=>{p.arg.track&&ze(i,p,h=>{h.requestId===p.requestId&&(h.status="rejected",h.error=s??T)})}).addMatcher(x,(i,s)=>{let{mutations:T}=Q(s);for(let[p,h]of Object.entries(T))(h?.status==="fulfilled"||h?.status==="rejected")&&p!==h?.requestId&&(i[p]=h)})}}),n=V({name:`${e}/invalidation`,initialState:se,reducers:{updateProvidedBy:{reducer(a,i){let{queryCacheKey:s,providedTags:T}=i.payload;for(let p of Object.values(a))for(let h of Object.values(p)){let b=h.indexOf(s);b!==-1&&h.splice(b,1)}for(let{type:p,id:h}of T){let b=(a[p]??={})[h||"__internal_without_id"]??=[];b.includes(s)||b.push(s)}},prepare:Y()}},extraReducers(a){a.addCase(S.actions.removeQueryResult,(i,{payload:{queryCacheKey:s}})=>{for(let T of Object.values(i))for(let p of Object.values(T)){let h=p.indexOf(s);h!==-1&&p.splice(h,1)}}).addMatcher(x,(i,s)=>{let{provided:T}=Q(s);for(let[p,h]of Object.entries(T))for(let[b,A]of Object.entries(h)){let k=(i[p]??={})[b||"__internal_without_id"]??=[];for(let D of A)k.includes(D)||k.push(D)}}).addMatcher(re(q(r),G(r)),(i,s)=>{let T=le(s,"providesTags",g,E),{queryCacheKey:p}=s.meta.arg;n.caseReducers.updateProvidedBy(i,n.actions.updateProvidedBy({queryCacheKey:p,providedTags:T}))})}}),t=V({name:`${e}/subscriptions`,initialState:se,reducers:{updateSubscriptionOptions(a,i){},unsubscribeQueryResult(a,i){},internal_getRTKQSubscriptions(){}}}),m=V({name:`${e}/internalSubscriptions`,initialState:se,reducers:{subscriptionsUpdated:{reducer(a,i){return Le(a,i.payload)},prepare:Y()}}}),R=V({name:`${e}/config`,initialState:{online:Be(),focused:ve(),middlewareRegistered:!1,...M},reducers:{middlewareRegistered(a,{payload:i}){a.middlewareRegistered=a.middlewareRegistered==="conflict"||l!==i?"conflict":!0}},extraReducers:a=>{a.addCase(W,i=>{i.online=!0}).addCase(Z,i=>{i.online=!1}).addCase(z,i=>{i.focused=!0}).addCase(X,i=>{i.focused=!1}).addMatcher(x,i=>({...i}))}}),y=Fe({queries:S.reducer,mutations:d.reducer,provided:n.reducer,subscriptions:m.reducer,config:R.reducer}),u=(a,i)=>y(f.match(i)?void 0:a,i),o={...R.actions,...S.actions,...t.actions,...m.actions,...d.actions,...n.actions,resetApiState:f};return{reducer:u,actions:o}}var me=Symbol.for("RTKQ/skipToken"),Je={status:"uninitialized"},Ve=ne(Je,()=>{}),$e=ne(Je,()=>{});function Ge({serializeQueryArgs:e,reducerPath:r,createSelector:c}){let g=d=>Ve,l=d=>$e;return{buildQuerySelector:E,buildMutationSelector:M,selectInvalidatedBy:f,selectCachedArgsForQuery:S};function Q(d){return{...d,...Ee(d.status)}}function x(d){return d[r]}function E(d,n){return t=>{let m=e({queryArgs:t,endpointDefinition:n,endpointName:d});return c(t===me?g:u=>x(u)?.queries?.[m]??Ve,Q)}}function M(){return d=>{let n;return typeof d=="object"?n=$(d)??me:n=d,c(n===me?l:R=>x(R)?.mutations?.[n]??$e,Q)}}function f(d,n){let t=d[r],m=new Set;for(let R of n.map(pe)){let y=t.provided[R.type];if(!y)continue;let u=(R.id!==void 0?y[R.id]:Qe(Object.values(y)))??[];for(let o of u)m.add(o)}return Qe(Array.from(m.values()).map(R=>{let y=t.queries[R];return y?[{queryCacheKey:R,endpointName:y.endpointName,originalArgs:y.originalArgs}]:[]}))}function S(d,n){return Object.values(d[r].queries).filter(t=>t?.endpointName===n&&t.status!=="uninitialized").map(t=>t.originalArgs)}}import{formatProdErrorMessage as Dt}from"@reduxjs/toolkit";var Ye=WeakMap?new WeakMap:void 0,ge=({endpointName:e,queryArgs:r})=>{let c="",g=Ye?.get(r);if(typeof g=="string")c=g;else{let l=JSON.stringify(r,(Q,x)=>(x=typeof x=="bigint"?{$bigint:x.toString()}:x,x=L(x)?Object.keys(x).sort().reduce((E,M)=>(E[M]=x[M],E),{}):x,x));L(r)&&Ye?.set(r,l),c=l}return`${e}(${c})`};import{weakMapMemoize as Xe}from"reselect";function De(...e){return function(c){let g=Xe(f=>c.extractRehydrationInfo?.(f,{reducerPath:c.reducerPath??"api"})),l={reducerPath:"api",keepUnusedDataFor:60,refetchOnMountOrArgChange:!1,refetchOnFocus:!1,refetchOnReconnect:!1,invalidationBehavior:"delayed",...c,extractRehydrationInfo:g,serializeQueryArgs(f){let S=ge;if("serializeQueryArgs"in f.endpointDefinition){let d=f.endpointDefinition.serializeQueryArgs;S=n=>{let t=d(n);return typeof t=="string"?t:ge({...n,queryArgs:t})}}else c.serializeQueryArgs&&(S=c.serializeQueryArgs);return S(f)},tagTypes:[...c.tagTypes||[]]},Q={endpointDefinitions:{},batch(f){f()},apiUid:Ce(),extractRehydrationInfo:g,hasRehydrationInfo:Xe(f=>g(f)!=null)},x={injectEndpoints:M,enhanceEndpoints({addTagTypes:f,endpoints:S}){if(f)for(let d of f)l.tagTypes.includes(d)||l.tagTypes.push(d);if(S)for(let[d,n]of Object.entries(S))typeof n=="function"?n(Q.endpointDefinitions[d]):Object.assign(Q.endpointDefinitions[d]||{},n);return x}},E=e.map(f=>f.init(x,l,Q));function M(f){let S=f.endpoints({query:d=>({...d,type:"query"}),mutation:d=>({...d,type:"mutation"})});for(let[d,n]of Object.entries(S)){if(f.overrideExisting!==!0&&d in Q.endpointDefinitions){if(f.overrideExisting==="throw")throw new Error(Dt(39));typeof process<"u";continue}Q.endpointDefinitions[d]=n;for(let t of E)t.injectEndpoint(d,n)}return x}return x.injectEndpoints({endpoints:c.endpoints})}}import{formatProdErrorMessage as bt}from"@reduxjs/toolkit";function Et(){return function(){throw new Error(bt(33))}}import{isAnyOf as Mt}from"@reduxjs/toolkit";function kt(e){for(let r in e)return!1;return!0}var Bt=2147483647/1e3-1,Ze=({reducerPath:e,api:r,queryThunk:c,context:g,internalState:l})=>{let{removeQueryResult:Q,unsubscribeQueryResult:x}=r.internalActions,E=Mt(x.match,c.fulfilled,c.rejected);function M(n){let t=l.currentSubscriptions[n];return!!t&&!kt(t)}let f={},S=(n,t,m)=>{if(E(n)){let R=t.getState()[e],{queryCacheKey:y}=x.match(n)?n.payload:n.meta.arg;d(y,R.queries[y]?.endpointName,t,R.config)}if(r.util.resetApiState.match(n))for(let[R,y]of Object.entries(f))y&&clearTimeout(y),delete f[R];if(g.hasRehydrationInfo(n)){let R=t.getState()[e],{queries:y}=g.extractRehydrationInfo(n);for(let[u,o]of Object.entries(y))d(u,o?.endpointName,t,R.config)}};function d(n,t,m,R){let u=g.endpointDefinitions[t]?.keepUnusedDataFor??R.keepUnusedDataFor;if(u===1/0)return;let o=Math.max(0,Math.min(u,Bt));if(!M(n)){let a=f[n];a&&clearTimeout(a),f[n]=setTimeout(()=>{M(n)||m.dispatch(Q({queryCacheKey:n})),delete f[n]},o*1e3)}}return S};var et=({reducerPath:e,context:r,context:{endpointDefinitions:c},mutationThunk:g,queryThunk:l,api:Q,assertTagType:x,refetchQuery:E,internalState:M})=>{let{removeQueryResult:f}=Q.internalActions,S=re(q(g),G(g)),d=re(q(g,l),J(g,l)),n=[],t=(y,u)=>{S(y)?R(le(y,"invalidatesTags",c,x),u):d(y)?R([],u):Q.util.invalidateTags.match(y)&&R(oe(y.payload,void 0,void 0,void 0,void 0,x),u)};function m(y){for(let u in y.queries)if(y.queries[u]?.status==="pending")return!0;for(let u in y.mutations)if(y.mutations[u]?.status==="pending")return!0;return!1}function R(y,u){let o=u.getState(),a=o[e];if(n.push(...y),a.config.invalidationBehavior==="delayed"&&m(a))return;let i=n;if(n=[],i.length===0)return;let s=Q.util.selectInvalidatedBy(o,i);r.batch(()=>{let T=Array.from(s.values());for(let{queryCacheKey:p}of T){let h=a.queries[p],b=M.currentSubscriptions[p]??{};h&&(U(b)===0?u.dispatch(f({queryCacheKey:p})):h.status!=="uninitialized"&&u.dispatch(E(h,p)))}})}return t};var tt=({reducerPath:e,queryThunk:r,api:c,refetchQuery:g,internalState:l})=>{let Q={},x=(n,t)=>{(c.internalActions.updateSubscriptionOptions.match(n)||c.internalActions.unsubscribeQueryResult.match(n))&&M(n.payload,t),(r.pending.match(n)||r.rejected.match(n)&&n.meta.condition)&&M(n.meta.arg,t),(r.fulfilled.match(n)||r.rejected.match(n)&&!n.meta.condition)&&E(n.meta.arg,t),c.util.resetApiState.match(n)&&S()};function E({queryCacheKey:n},t){let m=t.getState()[e],R=m.queries[n],y=l.currentSubscriptions[n];if(!R||R.status==="uninitialized")return;let{lowestPollingInterval:u,skipPollingIfUnfocused:o}=d(y);if(!Number.isFinite(u))return;let a=Q[n];a?.timeout&&(clearTimeout(a.timeout),a.timeout=void 0);let i=Date.now()+u;Q[n]={nextPollTimestamp:i,pollingInterval:u,timeout:setTimeout(()=>{(m.config.focused||!o)&&t.dispatch(g(R,n)),E({queryCacheKey:n},t)},u)}}function M({queryCacheKey:n},t){let R=t.getState()[e].queries[n],y=l.currentSubscriptions[n];if(!R||R.status==="uninitialized")return;let{lowestPollingInterval:u}=d(y);if(!Number.isFinite(u)){f(n);return}let o=Q[n],a=Date.now()+u;(!o||a<o.nextPollTimestamp)&&E({queryCacheKey:n},t)}function f(n){let t=Q[n];t?.timeout&&clearTimeout(t.timeout),delete Q[n]}function S(){for(let n of Object.keys(Q))f(n)}function d(n={}){let t=!1,m=Number.POSITIVE_INFINITY;for(let R in n)n[R].pollingInterval&&(m=Math.min(n[R].pollingInterval,m),t=n[R].skipPollingIfUnfocused||t);return{lowestPollingInterval:m,skipPollingIfUnfocused:t}}return x};var nt=({reducerPath:e,context:r,api:c,refetchQuery:g,internalState:l})=>{let{removeQueryResult:Q}=c.internalActions,x=(M,f)=>{z.match(M)&&E(f,"refetchOnFocus"),W.match(M)&&E(f,"refetchOnReconnect")};function E(M,f){let S=M.getState()[e],d=S.queries,n=l.currentSubscriptions;r.batch(()=>{for(let t of Object.keys(n)){let m=d[t],R=n[t];if(!R||!m)continue;(Object.values(R).some(u=>u[f]===!0)||Object.values(R).every(u=>u[f]===void 0)&&S.config[f])&&(U(R)===0?M.dispatch(Q({queryCacheKey:t})):m.status!=="uninitialized"&&M.dispatch(g(m,t)))}})}return x};var rt=new Error("Promise never resolved before cacheEntryRemoved."),it=({api:e,reducerPath:r,context:c,queryThunk:g,mutationThunk:l,internalState:Q})=>{let x=xe(g),E=xe(l),M=q(g,l),f={},S=(t,m,R)=>{let y=d(t);if(g.pending.match(t)){let u=R[r].queries[y],o=m.getState()[r].queries[y];!u&&o&&n(t.meta.arg.endpointName,t.meta.arg.originalArgs,y,m,t.meta.requestId)}else if(l.pending.match(t))m.getState()[r].mutations[y]&&n(t.meta.arg.endpointName,t.meta.arg.originalArgs,y,m,t.meta.requestId);else if(M(t)){let u=f[y];u?.valueResolved&&(u.valueResolved({data:t.payload,meta:t.meta.baseQueryMeta}),delete u.valueResolved)}else if(e.internalActions.removeQueryResult.match(t)||e.internalActions.removeMutationResult.match(t)){let u=f[y];u&&(delete f[y],u.cacheEntryRemoved())}else if(e.util.resetApiState.match(t))for(let[u,o]of Object.entries(f))delete f[u],o.cacheEntryRemoved()};function d(t){return x(t)?t.meta.arg.queryCacheKey:E(t)?t.meta.arg.fixedCacheKey??t.meta.requestId:e.internalActions.removeQueryResult.match(t)?t.payload.queryCacheKey:e.internalActions.removeMutationResult.match(t)?$(t.payload):""}function n(t,m,R,y,u){let o=c.endpointDefinitions[t],a=o?.onCacheEntryAdded;if(!a)return;let i={},s=new Promise(k=>{i.cacheEntryRemoved=k}),T=Promise.race([new Promise(k=>{i.valueResolved=k}),s.then(()=>{throw rt})]);T.catch(()=>{}),f[R]=i;let p=e.endpoints[t].select(o.type==="query"?m:R),h=y.dispatch((k,D,B)=>B),b={...y,getCacheEntry:()=>p(y.getState()),requestId:u,extra:h,updateCachedData:o.type==="query"?k=>y.dispatch(e.util.updateQueryData(t,m,k)):void 0,cacheDataLoaded:T,cacheEntryRemoved:s},A=a(m,b);Promise.resolve(A).catch(k=>{if(k!==rt)throw k})}return S};var ot=({api:e,context:r,queryThunk:c,mutationThunk:g})=>{let l=ye(c,g),Q=J(c,g),x=q(c,g),E={};return(f,S)=>{if(l(f)){let{requestId:d,arg:{endpointName:n,originalArgs:t}}=f.meta,m=r.endpointDefinitions[n],R=m?.onQueryStarted;if(R){let y={},u=new Promise((s,T)=>{y.resolve=s,y.reject=T});u.catch(()=>{}),E[d]=y;let o=e.endpoints[n].select(m.type==="query"?t:d),a=S.dispatch((s,T,p)=>p),i={...S,getCacheEntry:()=>o(S.getState()),requestId:d,extra:a,updateCachedData:m.type==="query"?s=>S.dispatch(e.util.updateQueryData(n,t,s)):void 0,queryFulfilled:u};R(t,i)}}else if(x(f)){let{requestId:d,baseQueryMeta:n}=f.meta;E[d]?.resolve({data:f.payload,meta:n}),delete E[d]}else if(Q(f)){let{requestId:d,rejectedWithValue:n,baseQueryMeta:t}=f.meta;E[d]?.reject({error:f.payload??f.error,isUnhandledError:!n,meta:t}),delete E[d]}}};var at=({api:e,context:{apiUid:r},reducerPath:c})=>(g,l)=>{e.util.resetApiState.match(g)&&l.dispatch(e.internalActions.middlewareRegistered(r)),typeof process<"u"};import{produceWithPatches as vt}from"immer";var st=({api:e,queryThunk:r,internalState:c})=>{let g=`${e.reducerPath}/subscriptions`,l=null,Q=null,{updateSubscriptionOptions:x,unsubscribeQueryResult:E}=e.internalActions,M=(t,m)=>{if(x.match(m)){let{queryCacheKey:y,requestId:u,options:o}=m.payload;return t?.[y]?.[u]&&(t[y][u]=o),!0}if(E.match(m)){let{queryCacheKey:y,requestId:u}=m.payload;return t[y]&&delete t[y][u],!0}if(e.internalActions.removeQueryResult.match(m))return delete t[m.payload.queryCacheKey],!0;if(r.pending.match(m)){let{meta:{arg:y,requestId:u}}=m,o=t[y.queryCacheKey]??={};return o[`${u}_running`]={},y.subscribe&&(o[u]=y.subscriptionOptions??o[u]??{}),!0}let R=!1;if(r.fulfilled.match(m)||r.rejected.match(m)){let y=t[m.meta.arg.queryCacheKey]||{},u=`${m.meta.requestId}_running`;R||=!!y[u],delete y[u]}if(r.rejected.match(m)){let{meta:{condition:y,arg:u,requestId:o}}=m;if(y&&u.subscribe){let a=t[u.queryCacheKey]??={};a[o]=u.subscriptionOptions??a[o]??{},R=!0}}return R},f=()=>c.currentSubscriptions,n={getSubscriptions:f,getSubscriptionCount:t=>{let R=f()[t]??{};return U(R)},isRequestSubscribed:(t,m)=>!!f()?.[t]?.[m]};return(t,m)=>{if(l||(l=JSON.parse(JSON.stringify(c.currentSubscriptions))),e.util.resetApiState.match(t))return l=c.currentSubscriptions={},Q=null,[!0,!1];if(e.internalActions.internal_getRTKQSubscriptions.match(t))return[!1,n];let R=M(c.currentSubscriptions,t),y=!0;if(R){Q||(Q=setTimeout(()=>{let a=JSON.parse(JSON.stringify(c.currentSubscriptions)),[,i]=vt(l,()=>a);m.next(e.internalActions.subscriptionsUpdated(i)),l=a,Q=null},500));let u=typeof t.type=="string"&&!!t.type.startsWith(g),o=r.rejected.match(t)&&t.meta.condition&&!!t.meta.arg.subscribe;y=!u&&!o}return[y,!1]}};function ut(e){let{reducerPath:r,queryThunk:c,api:g,context:l}=e,{apiUid:Q}=l,x={invalidateTags:H(`${r}/invalidateTags`)},E=d=>d.type.startsWith(`${r}/`),M=[at,Ze,et,tt,it,ot];return{middleware:d=>{let n=!1,m={...e,internalState:{currentSubscriptions:{}},refetchQuery:S,isThisApiSliceAction:E},R=M.map(o=>o(m)),y=st(m),u=nt(m);return o=>a=>{if(!we(a))return o(a);n||(n=!0,d.dispatch(g.internalActions.middlewareRegistered(Q)));let i={...d,next:o},s=d.getState(),[T,p]=y(a,i,s),h;if(T?h=o(a):h=p,d.getState()[r]&&(u(a,i,s),E(a)||l.hasRehydrationInfo(a)))for(let b of R)b(a,i,s);return h}},actions:x};function S(d,n,t={}){return c({type:"query",endpointName:d.endpointName,originalArgs:d.originalArgs,subscribe:!1,forceRefetch:!0,queryCacheKey:n,...t})}}function _(e,...r){return Object.assign(e,...r)}import{enablePatches as Pt}from"immer";var Te=Symbol(),be=({createSelector:e=Pe}={})=>({name:Te,init(r,{baseQuery:c,tagTypes:g,reducerPath:l,serializeQueryArgs:Q,keepUnusedDataFor:x,refetchOnMountOrArgChange:E,refetchOnFocus:M,refetchOnReconnect:f,invalidationBehavior:S},d){Pt();let n=C=>(typeof process<"u",C);Object.assign(r,{reducerPath:l,endpoints:{},internalActions:{onOnline:W,onOffline:Z,onFocus:z,onFocusLost:X},util:{}});let{queryThunk:t,mutationThunk:m,patchQueryData:R,updateQueryData:y,upsertQueryData:u,prefetch:o,buildMatchThunkActions:a}=_e({baseQuery:c,reducerPath:l,context:d,api:r,serializeQueryArgs:Q,assertTagType:n}),{reducer:i,actions:s}=We({context:d,queryThunk:t,mutationThunk:m,reducerPath:l,assertTagType:n,config:{refetchOnFocus:M,refetchOnReconnect:f,refetchOnMountOrArgChange:E,keepUnusedDataFor:x,reducerPath:l,invalidationBehavior:S}});_(r.util,{patchQueryData:R,updateQueryData:y,upsertQueryData:u,prefetch:o,resetApiState:s.resetApiState}),_(r.internalActions,s);let{middleware:T,actions:p}=ut({reducerPath:l,context:d,queryThunk:t,mutationThunk:m,api:r,assertTagType:n});_(r.util,p),_(r,{reducer:i,middleware:T});let{buildQuerySelector:h,buildMutationSelector:b,selectInvalidatedBy:A,selectCachedArgsForQuery:k}=Ge({serializeQueryArgs:Q,reducerPath:l,createSelector:e});_(r.util,{selectInvalidatedBy:A,selectCachedArgsForQuery:k});let{buildInitiateQuery:D,buildInitiateMutation:B,getRunningMutationThunk:v,getRunningMutationsThunk:w,getRunningQueriesThunk:I,getRunningQueryThunk:N}=Ue({queryThunk:t,mutationThunk:m,api:r,serializeQueryArgs:Q,context:d});return _(r.util,{getRunningMutationThunk:v,getRunningMutationsThunk:w,getRunningQueryThunk:N,getRunningQueriesThunk:I}),{name:Te,injectEndpoint(C,K){let O=r;O.endpoints[C]??={},ce(K)?_(O.endpoints[C],{name:C,select:h(C,K),initiate:D(C,K)},a(t,C)):Ke(K)&&_(O.endpoints[C],{name:C,select:b(),initiate:B(C)},a(m,C))}}}});var Ft=De(be());export{he as QueryStatus,De as buildCreateApi,de as copyWithStructuralSharing,be as coreModule,Te as coreModuleName,Ft as createApi,ge as defaultSerializeQueryArgs,Et as fakeBaseQuery,lt as fetchBaseQuery,Tt as retry,ht as setupListeners,me as skipToken};
//# sourceMappingURL=rtk-query.browser.mjs.map